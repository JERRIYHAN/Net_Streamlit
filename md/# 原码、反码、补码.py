import streamlit as st

a='''# 原码、反码、补码

归根结底，是为了解决减法的问题。
使用补码，可以将（正数）-（正数）的**减法**运算变为（正数）+（负数）的**加法**运算

---
## 原码
首位：符号位（正数为0，负数为1）
14 = 0000 1110
-21 = 1001 0101

---
## 反码
正数：反码=原码
负数：符号位保持==1==，后面0 1 颠倒
-21 = 1110 1010

---
## 补码
正数：原码=反码=补码
负数：反码+1
-21 = 1110 1011

---
## 计算机计算方法:补码
    eg： 14-21
    0000 1110 + 1110 1011 = 1111 1001

将结果转化为原码：先-1，在反一反
1111 1001 --> 1111 1000 --> 1000 0111 --> -7


---
## 更简单的理解：补码（（以8位为例））

    将二进制0000 0000 - 1111 1111 这256个表示分配给-128到127这256个数，分配规则如下：
* 0到127:与一般二进制数一致，从0000 0000到0111 1111
* -128到-1:将剩下的位置依次分配，从1000 0000 到 1111 1111
* 负数的补码：将256-这个负数的绝对值，得到的正数的原码即可。

这种理解更加接近计算机的本质，通过进位溢出（若和为1 0000 0000，则最高位溢出，等于0000 0000），保证了负数运算的可行性，也使得0的唯一性确证。// 有一种轮转取模的味道
### 🌰栗子
    -127 + 127 = 0
    1000 0001 + 0111 1111 = 1 0000 0000 = 0

    -128 + 1 = -127
    1000 0000 + 0000 0001 = 1000 0001 = -127


---
参考：https://www.bilibili.com/video/BV16U4y1t7LD/?spm_id_from=333.788.recommend_more_video.0&vd_source=a49d84e28d5494b297e4890b96349fa7'''

st.markdown(a)
